# -*- coding: utf-8 -*-
"""final-test_vu-my-linh_nasa-exoplanets-classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/Linhvm312/8c12c299128aa2f2533b05bb5193b316/final-test_vu-my-linh_nasa-exoplanets-classification.ipynb
"""

import matplotlib.pyplot as plt
from sklearn import datasets
from sklearn import svm
from sklearn.model_selection import train_test_split
import numpy as np
import pandas as pd

link = 'https://drive.google.com/file/d/1eoNt2W-lBdsTq5gbUtLtGIVyrgTLUmvU/view?usp=share_link'

path = 'https://drive.google.com/uc?export=download&id='+link.split('/')[-2]
df = pd.read_csv(path)

df.head(10)

# name:               Tên của hành tinh theo được cung cấp bởi NASA
# distance:           khoảng cách của hành tinh từ trái đất (light years)
# stellar_magnitude:  Độ sáng của hành tinh, hành tinh càng sáng thì số càng thấp được gán cho hành tinh
# planet_type:        Loại hành tinh, những loại này có nguồn gốc từ các hành tinh trong hệ mặt trời của chúng ta
# discovery_year:     Năm mà hành tinh được phát hiện
# mass_multiplier:    hệ số nhân khối lượng của hành tinh với hành tinh mass_wrt tương ứng
# mass_wrt:           khối lượng của hành tinh so với khối lượng của các hành tinh trong hệ mặt trời của chúng ta
# radius_multiplier:  hệ số nhân bán kính của hành tinh với hành tinh radius_wrt tương ứng
# radius_wrt:         bán kính của hành tinh so với bán kính của các hành tinh trong hệ mặt trời của chúng ta
# orbital_radius:     Bán kính quỹ đạo của các hành tinh quay quanh mặt trời của chúng (in AU)
# orbital_period:     Thời gian tính bằng năm để các hành tinh đó hoàn thành 1 quỹ đạo quanh ngôi sao của chúng (years)
# eccentricity:       độ lệch tâm về cơ bản cho biết đường quỹ đạo là hình tròn như thế nào, độ lệch tâm gần bằng 0 có nghĩa là đường quỹ đạo là một quỹ đạo tròn
# detection_method:   Phương pháp được NASA sử dụng để tìm ngoại hành tinh đó

"""Data Preprocessing & EDA"""

df.info()

# name

df['name'].value_counts()

# distance

df['distance'].isnull().sum()

df['distance'].plot(kind='box')

"""* 17 dữ liệu bị mất
* cột này có rất nhiều ngoại lệ outliers, nhưng không quá quan trọng vì đó là khoảng cách chính xác của các hành tinh đó so với hệ mặt trời của chúng ta
"""

# stellar_magnitude

df['stellar_magnitude'].isnull().sum()

df['stellar_magnitude'].plot(kind='box')

"""* 161 dữ liệu bị mất

* Số lượng các hành tinh được NASA tìm thấy hầu hết có stellar_magnitude cao (các hành tinh mờ)
"""

# planet_type

df['planet_type'].value_counts()

df['planet_type'].value_counts().plot.barh()

df['planet_type'].value_counts().plot(kind='pie',autopct='%.1f%%',explode=[0.1,0,0,0.1,0])

"""* không có giá trị null, nhưng có 5 hành tinh vẫn chưa xác định được là loại hành tinh gì

* số lượng hành tinh có thể ở được là 1595 (Super Earth)
"""

# discovery_year

df['discovery_year'].value_counts()

df['discovery_year'].isnull().sum()

df['discovery_year'].value_counts().plot(kind='barh', figsize=(8, 6))

"""* vào năm 2016 số lượng của các hành tinh được phát hiện nhiều nhất (1517)

* không có giá trị null
"""

# mass_multiplier & mass_wrt

df['mass_multiplier'].isnull().sum()

df['mass_wrt'].isnull().sum()

df['mass_wrt'].value_counts().plot.barh()

# so với Earth:
df[df['mass_wrt'] == 'Earth']['mass_multiplier'].plot(kind='box')

# so với Jupiter
df[df['mass_wrt'] == 'Jupiter']['mass_multiplier'].plot(kind='box')

"""=> Có 23 hành tinh ko có số liệu về mass (khối lượng)

Earth

* có nhiều outliers

Jupiter

* có nhiều outliers
* có 1 hành tinh có khối lượng gấp 700 lần Jupiter
"""

# radius_multiplier & radius_wrt

df['radius_wrt'].isnull().sum()

df['radius_multiplier'].isnull().sum()

df['radius_wrt'].value_counts().plot.barh()

# so với Earth:
df[df['radius_wrt'] == 'Earth']['radius_multiplier'].plot(kind='box')

# so với Jupiter
df[df['radius_wrt'] == 'Jupiter']['radius_multiplier'].plot(kind='box')

"""=> bán kính của 17 hành tinh bị thiếu

Earth

* không có outliers

Jupiter

* có một vài hành tinh có bán kính outliers
* có 1 hành tinh có kích thước gấp 7 lần Jupiter
"""

# orbital_radius

df['orbital_radius'].isnull().sum()

df['orbital_radius'].plot(kind='box')

"""* có 289 hành tinh không có dữ liệu quỹ đạo bay

* có một số hành tinh có quỹ đạo bay outliers

* có hành tinh có quỹ đạo bay quanh ngôi sao của nó là lớn hơn 7000 AU
"""

# orbital_period

df['orbital_period'].isnull().sum()

df['orbital_period'].plot(kind='box')

"""* không có giá trị null

* có một số hành tinh có thời gian bay hết 1 vòng quỹ đạo outliers

* có một hành tinh mất ~1 triệu năm để hoàn thành một vòng quay xung quanh ngôi sao của nó
"""

# eccentricity

df['eccentricity'].isnull().sum()

df['eccentricity'].plot(kind='box')

"""* các hành tinh có 3 loại quỹ đạo theo độ lệch tâm (eccentricity) đường quỹ đạo của chúng:

  1. Hình tròn: e = 0 or ~0
  2. Hình Parabola: e = 1 or ~1
  3. Hình ellipse: 0 < e < 1
* hầu hết các hành tinh đều có quỹ đạo hình elip
* có 3 hành tinh có độ lệch tâm âm (<0), theo như tìm hiểu thì dấu âm không ảnh hưởng tới hình dạng quỹ đạo của hành tinh đó. Đã so sánh với dữ liệu trên trang chính thống của NASA, dữ liệu của 3 hành tinh không sai.
"""

# detection_method

df['detection_method'].isnull().sum()

df['detection_method'].value_counts()

df['detection_method'].value_counts().plot.barh()

"""* phương pháp được sử dụng nhiều nhất để tìm ngoại hành tinh là Transit
* không có dữ liệu bị mất
"""

import seaborn as sns
sns.scatterplot(x = "distance", y = "discovery_year", hue = "planet_type", style = "planet_type",data = df)



"""**Xứ lý data null**"""

df=df.replace("?", np.nan)

df.isnull().sum()

# drop các biến na vì những dữ liệu này ko thể tự thay thế hoặc dự đoán mà phải có dữ liệu thực tế của các ngoại hành tinh
df.dropna(axis=0,inplace=True)
df.info()

"""**Target: planet_type**"""

x = df.drop(['name','discovery_year', 'planet_type','mass_wrt','radius_wrt','detection_method'],axis=1)
data = df[['mass_wrt','radius_wrt','detection_method']]
# mã hóa LabelEncoder
from sklearn import preprocessing
from sklearn.preprocessing import LabelEncoder
X_dum = data.apply(LabelEncoder().fit_transform)

X = pd.concat([x,X_dum],axis=1)
y = df['planet_type']

X

y

y.value_counts()

"""**Standardisation**

Dùng Standardisation vì data có nhiều outliers nhưng những outliers này lại là thông tin thực tế, không thể thay đổi và cũng không thể giảm bớt những thông tin này khỏi việc classify các loại hành tinh (như khi dùng Min Max).
"""

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_std = sc.fit_transform(X)

from sklearn.metrics import accuracy_score

X_std = pd.DataFrame(X_std, columns = ["distance",	"stellar_magnitude",	"mass_multiplier",	"radius_multiplier",	"orbital_radius",	"orbital_period",	"eccentricity",
                                "mass_wrt",	"radius_wrt",	"detection_method"])
X_std

"""**Train size, test size**"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X_std, y, test_size=0.3)

pd.DataFrame(X_train, columns = ["distance",	"stellar_magnitude",	"mass_multiplier",	"radius_multiplier",	"orbital_radius",	"orbital_period",	"eccentricity",
                                "mass_wrt",	"radius_wrt",	"detection_method"])

y_train

"""**ML Models**"""

### Logistic Regression

from sklearn.linear_model import LogisticRegression
ModelLR = LogisticRegression(max_iter=200).fit(X_train,y_train)
y_pred_logis = ModelLR.predict(X_test)
print("Accuracy of LR:",accuracy_score(y_test,y_pred_logis))

import seaborn as sns
from sklearn import metrics
cnf_matrix = metrics.confusion_matrix(y_test, y_pred_logis)
cnf_matrix
class_names=[0,1] # name  of classes
fig, ax = plt.subplots()
tick_marks = np.arange(len(class_names))
plt.xticks(tick_marks, class_names)
plt.yticks(tick_marks, class_names)
# create heatmap
sns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap="YlGnBu" ,fmt='g')
plt.tight_layout()
plt.title('Confusion matrix', y=1.1)
plt.ylabel('Actual label')
plt.xlabel('Predicted label')

### KNN

from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier().fit(X_train,y_train)
y_pred_knn = knn.predict(X_test)
print("Accuracy of KNN:",accuracy_score(y_test,y_pred_knn))

import seaborn as sns
from sklearn import metrics
cnf_matrix = metrics.confusion_matrix(y_test, y_pred_knn)
cnf_matrix
class_names=[0,1] # name  of classes
fig, ax = plt.subplots()
tick_marks = np.arange(len(class_names))
plt.xticks(tick_marks, class_names)
plt.yticks(tick_marks, class_names)
# create heatmap
sns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap="YlGnBu" ,fmt='g')
plt.tight_layout()
plt.title('Confusion matrix', y=1.1)
plt.ylabel('Actual label')
plt.xlabel('Predicted label')

### GaussianNB

from sklearn.naive_bayes import GaussianNB
GNB = GaussianNB().fit(X_train, y_train) # Training mô hình
y_pred_gnb=GNB.predict(X_test)
print("Accuracy of GNB:",accuracy_score(y_test,y_pred_gnb))

import seaborn as sns
from sklearn import metrics
cnf_matrix = metrics.confusion_matrix(y_test, y_pred_gnb)
cnf_matrix
class_names=[0,1] # name  of classes
fig, ax = plt.subplots()
tick_marks = np.arange(len(class_names))
plt.xticks(tick_marks, class_names)
plt.yticks(tick_marks, class_names)
# create heatmap
sns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap="YlGnBu" ,fmt='g')
plt.tight_layout()
plt.title('Confusion matrix', y=1.1)
plt.ylabel('Actual label')
plt.xlabel('Predicted label')

### Decision Tree

from sklearn.tree import DecisionTreeClassifier
dt = DecisionTreeClassifier().fit(X_train,y_train)
y_pred_dt = dt.predict(X_test)
print("Accuracy of Decision Tree:",accuracy_score(y_test,y_pred_dt))

import seaborn as sns
from sklearn import metrics
cnf_matrix = metrics.confusion_matrix(y_test, y_pred_dt)
cnf_matrix
class_names=[0,1] # name  of classes
fig, ax = plt.subplots()
tick_marks = np.arange(len(class_names))
plt.xticks(tick_marks, class_names)
plt.yticks(tick_marks, class_names)
# create heatmap
sns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap="YlGnBu" ,fmt='g')
plt.tight_layout()
plt.title('Confusion matrix', y=1.1)
plt.ylabel('Actual label')
plt.xlabel('Predicted label')

"""**Confusion Matrix:**
- Chạy 4 mô hình: LogisticRegression, K-Near Neighbors, Gaussian Naive Bayes và Decision Tree để phân loại các ngoại hành tinh.
- Trong cả 4 thì Decision Tree có độ chính xác là cao nhất, và có tổng số dự đoán sai là ít nhất so với 3 mô hình còn lại.
- LR và KNN đều có dự đoán sai khá nhiều cho loại hành tinh Neptune-like và Super Earth.
- GNB cũng mắc nhiều sai lầm khi dự đoán 2 hành tinh này nhưng nhiều nhất là Super-Earth.

=> Ta sử dụng mô hình Decision Tree để phân loại các ngoại hành tinh sẽ có độ chính xác cao nhất.

"""

from sklearn import tree
X, y = X_std, y
model = tree.DecisionTreeClassifier()
model = model.fit(X, y)
import graphviz
dot_data = tree.export_graphviz(model, out_file=None,feature_names=["distance",	"stellar_magnitude",	"mass_multiplier",	"radius_multiplier",	"orbital_radius",	"orbital_period",	"eccentricity",
                                                                    "mass_wrt",	"radius_wrt",	"detection_method"], class_names=["Neptune-like", "Gas Giant", "Super Earth", "Terrestrial"],
                                filled=True, rounded=True, special_characters=True)
graph = graphviz.Source(dot_data)
graph

from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import LogisticRegression
import datetime
from sklearn.model_selection import cross_val_score

models = [
    LogisticRegression(max_iter=200),
    KNeighborsClassifier(),
    GaussianNB(),
    DecisionTreeClassifier()
]
CV = 20
entries = []
i=0
for model in models:
    scores_train = []
    scores_test = []
    times = []
    abs_scores = []
    for j in range(CV):
        t1 = datetime.datetime.now()
        model_name = model.__class__.__name__
        model.fit(X_train,y_train)
        t2 = datetime.datetime.now()
        d = round((t2 - t1).microseconds/1000,1)
        score_train = model.score(X_train,y_train)
        score_test = model.score(X_test,y_test)
        abs_score = abs(score_train - score_test)

        scores_train.append(score_train)
        scores_test.append(score_test)
        abs_scores.append(abs_score)
        times.append(d)

    print(model.__class__.__name__, scores_test)
    entries.append([model_name, np.array(scores_train).mean(),
                    np.array(scores_test).mean(), np.array(abs_scores).mean(),
                    np.array(times).mean()])
    i += 1
cv_df = pd.DataFrame(entries,
                     columns=['model_name', 'score_train_mean',
                              'score_test_mean', 'abs|score|', 'time_mean'])

cv_df

"""**Cross-validation:**
- Dùng mô hình GNB sẽ đỡ tốn thời gian hơn nhưng điểm xác thực thấp nhất.
- LR thì quá mất thời gian.
- KNN và Decision có điểm xác thực asb|score| xấp xỉ, nhưng Decision Tree nhanh hơn.

**Conclusion:**
- Trong việc phân loại các loại hành tinh trong tương lai, việc sử dụng mô hình Decision Tree sẽ cho ra kết quả gần đúng nhất và hiệu quả nhất.
- Và việc sử dụng Decision Tree thì dễ dàng phân loại đúng ra loại hành tinh Gas Giants và Terrestrial.
- Để có thể phân loại đúng loại hành tinh Neptune-like và Super Earth thì nên có thêm nhiều các data khác về đặc điểm điển hình của các loại hành tinh này.
"""